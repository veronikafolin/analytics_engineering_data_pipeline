kpi:
  default_args:
    owner: 'v.folin@reply.it'
    email: ['v.folin@reply.it']
    email_on_failure: True
    start_date: 2023-12-28
    retries: 0
    snowflake_conn_id: snowflake
  schedule_interval: None
  dagrun_timeout_sec: 3600
  description: "To compute KPIs and send alerts"
  params:
    groupBy: [ ]
    filters: [ ]
    startPeriod: '1994-01-01'
    endPeriod: '1994-12-31'
    partitionByDate: CURRENT_DATE()
  render_template_as_native_obj: True
  tasks:
    trigger_kpi_supplier_lead_time:
      operator: airflow.operators.trigger_dagrun.TriggerDagRunOperator
      trigger_dag_id: 'kpi_supplier_lead_time'
      wait_for_completion: True
      deferrable: True
      failed_states: [ 'failed' ]
      conf:
        params:
          groupBy: "{{ params.groupBy }}"
          filters: "{{ params.filters }}"
          partitionByDate: "{{ params.partitionByDate }}"
kpi_supplier_lead_time:
  default_args:
    owner: 'v.folin@reply.it'
    email: [ 'v.folin@reply.it' ]
    email_on_failure: True
    start_date: 2023-12-28
    retries: 0
    snowflake_conn_id: snowflake
  schedule_interval: None
  dagrun_timeout_sec: 3600
  description: "To compute the time it takes suppliers to deliver orders."
  tasks:
    compute_supplier_lead_time:
      operator: airflow_dbt.operators.dbt_operator.DbtRunOperator
      models: 'kpi_supplier_lead_time'
      vars: { 'groupBy': "{{ params.groupBy }}", 'filters': "{{ params.filters }}", 'partitionByDate': "{{ params.partitionByDate }}" }
    check_supplier_lead_time:
      operator: airflow.providers.snowflake.operators.snowflake.SnowflakeCheckOperator
      sql: |
            SELECT NOT EXISTS (
              SELECT *
              FROM ANALYTICS.DBT_CORE_REUSABLE_DEMO.KPI_SUPPLIER_LEAD_TIME
              WHERE AVG_DELIVERY_DAYS > 16 );
      dependencies: [ compute_supplier_lead_time ]
#    compute_revenue:
#      operator: airflow_dbt.operators.dbt_operator.DbtRunOperator
#      models: 'kpi_revenue'
#      vars: { 'groupBy': "{{ params.groupBy }}", 'filters': "{{ params.filters }}", 'partitionByDate': "{{ params.partitionByDate }}" }
#    check_revenue:
#      operator: airflow.providers.snowflake.operators.snowflake.SnowflakeCheckOperator
#      sql: |
#        SELECT NOT EXISTS (
#          SELECT *
#          FROM ANALYTICS.DBT_CORE_REUSABLE_DEMO.KPI_REVENUE
#          WHERE AVG_REVENUE < 150000 );
#      dependencies: [ compute_revenue ]
#    compute_product_popularity:
#      operator: airflow_dbt.operators.dbt_operator.DbtRunOperator
#      models: 'kpi_product_popularity'
#      vars: { 'groupBy': "{{ params.groupBy }}", 'filters': "{{ params.filters }}", 'partitionByDate': "{{ params.partitionByDate }}" }
#    compute_order_return_rate:
#      operator: airflow_dbt.operators.dbt_operator.DbtRunOperator
#      models: 'kpi_order_return_rate'
#      vars: { 'groupBy': "{{ params.groupBy }}", 'filters': "{{ params.filters }}", 'partitionByDate': "{{ params.partitionByDate }}" }
#    check_order_return_rate:
#      operator: airflow.providers.snowflake.operators.snowflake.SnowflakeCheckOperator
#      sql: |
#        SELECT NOT EXISTS (
#          SELECT *
#          FROM ANALYTICS.DBT_CORE_REUSABLE_DEMO.KPI_ORDER_RETURN_RATE
#          WHERE ORDER_RETURN_RATE > 25 );
#      dependencies: [ compute_order_fulfillment_time ]
#    compute_order_fulfillment_time:
#      operator: airflow_dbt.operators.dbt_operator.DbtRunOperator
#      models: 'kpi_order_fulfillment_time'
#      vars: { 'groupBy': "{{ params.groupBy }}", 'filters': "{{ params.filters }}", 'partitionByDate': "{{ params.partitionByDate }}" }
#    check_order_fulfillment_time:
#      operator: airflow.providers.snowflake.operators.snowflake.SnowflakeCheckOperator
#      sql: |
#        SELECT NOT EXISTS (
#          SELECT *
#          FROM ANALYTICS.DBT_CORE_REUSABLE_DEMO.KPI_ORDER_FULFILLMENT_TIME
#          WHERE AVG_FULFILLMENT_DAYS > 80 );
#      dependencies: [ compute_order_fulfillment_time ]
